[TOC]

# 一、DNS

## 1、DNS是什么？

**官方解释**：DNS（Domain Name System，域名系统），因特网上作为**域名和IP地址相互映射**的一个**分布式数据库**，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。

通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。

**通俗的讲**，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。





## 2、DNS的工作原理？

将主机域名转换为ip地址，属于应用层协议，使用UDP传输。（DNS应用层协议，以前有个考官问过）

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103/QQ截图20210317172225.png) 



过程：**浏览器缓存，系统缓存，本地域名服务器，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。** 

一、主机向本地域名服务器的查询一般都是采用递归查询。 

二、本地域名服务器向根域名服务器的查询的迭代查询。 

1)当用户输入域名时，浏览器先检查自己的缓存中是否 这个域名映射的ip地址，有解析结束。 

2）若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。 

3）若无命中，则请求本地域名服务器解析（ LDNS）。 

4）若LDNS没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个 主域名服务器地址。

 5） 此时LDNS再发送请求给上一步返回的gTLD（ 通用顶级域）， 接受请求的gTLD查找并返回这个域名对应的Name Server的地址 

6） Name Server根据映射关系表找到目标ip，返回给LDNS 

7） LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束

# 二、HTTP

> HTTP定义了浏览器(万维网客户进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。
> 从层次的角度看，HTTP是面向事务的(Transaction-oriented) 应用层
> 协议，它规定了在浏览器和服务器之间的请求和响应的格式与规则，是万维网上能够可靠地交换文件(包括文本、声音、图像等各种多媒体文件)的重要基础。

## 1、HTTP操作过程

在浏览器和服务器之间的请求与响应的交互，必须遵循规定的格式和规则，这些格式和规则就是HTTP。
因此HTTP有两类报文:

1. 请求报文(从Web客户端向Web服务器发送服务请求)
2. 响应报文(从Web服务器对Web客户端请求的回答)。



- 从协议执行过程来说，浏览器要访问WWW服务器时，首先要完成对www服务器的域名解析。
- 一旦获得了服务器的IP地址，浏览器就通过TCP向服务器发送连接建立请求。万维网的大致工作过程如图所示

![img](https://img-blog.csdnimg.cn/20200503125028241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 每个万维网站点都有一个服务器进程，它不断地监听TCP的端口80(默认)，当监听到连接请求后便与浏览器建立连接。
- TCP连接建立后, 浏览器就向服务器发送请求获取某个Web页面的HTTP请求。
- 服务器收到HTTP请求后，将构建所请求Web页的必需信息，并通过HTTP响应返回给浏览器。
- 浏览器再将信息进行解释, .然后将Web页显示给用户。
- 最后，TCP连接释放。

## 2、HTTP特点

![img](https://img-blog.csdnimg.cn/20200503124926378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

1**.HTTP是无状态的**。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。
因为服务器并不记得曾经访问过的这个客户，也不记得为该客户曾经服务过多少次。
<u>HTTP的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的HTTP请求。</u>

2.在实际应用中，**通常使用Cookie 加数据库的方式来跟踪用户的活动(**如记录用户最近浏览的商品等)。
Cookie 是一个存储在用户主机中的文本文件，里面含有一-串“识别码”，如“123456”，用于Web服务识别用户。
Web服务器根据Cookie就能从数据库中查询到该用户的活动记录，进而执行一些个性化的工作，如根据用户之前浏览过的商品向其推荐新产品等。

3.HTTP采用TCP作为运输层协议，保证了数据的可靠传输。
HTTP不必考虑数据在传输过程中被丢弃后又怎样被重传。
但是，**HTTP本身是无连接的**。也就是说，虽然HTTP使用了TCP连接，但通信的双方在交换HTTP报文之前不需要先建立HTTP连接。

4.**HTTP既可以使用非持久连接，也可以使用持久连接**(HTTP/1.1支持)。对于非持久连接，每个网页元素对象(如JPEG图形、Flash 等)的传输都需要单独建立一个TCP连接，如图6.12所示(第三次握手的报文段中捎带了客户对万维网文档的请求)。
也就是说，请求一个万维网文档所需的时间是该文档的传输时间(与文档大小成正比)加上两倍往返时间RTT(一个RTT用于TCP连接，另一个RTT用于请求和接收文档)。

![img](https://img-blog.csdnimg.cn/20200503125530156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**长连接的优点**：
1、减少CPU及内存的使用，因为不需要经常的建立及关闭连接，当然高峰并发时CPU及内存也是比较多的；
2、允许[HTTP pipelining](http://en.wikipedia.org/wiki/HTTP_pipelining)（HTTP 1.1中支持）的请求及响应模式：
为了便于理解HTTP pipelining，参见下图：
![image-20210908170514731](C:\Users\SUSHOLD\AppData\Roaming\Typora\typora-user-images\image-20210908170514731.png)

3、减少网络的堵塞，因为减少了TCP请求； 根据[RFC 2616](http://tools.ietf.org/html/rfc2616) (page 46)的标准定义，单个客户端不允许开启2个以上的长连接，这个标准的目的是减少HTTP响应的时候，减少网络堵塞
4、减少后续请求的响应时间，因为此时不需要建立TCP，也不需要TCP握手等过程；
5、当发生错误时，可以在不关闭连接的情况下进行提示；
**长连接的缺点**：可能会损害服务器的整体性能，如apache的长连接时间的长短，直接影响到服务器的并发数。
**长连接在浏览器中的使用情况**：
Netscape从4.05开始支持，Netscape不是通过 timeout来关闭长连接，它是将空闲连接放置到一个队列中，当有需要向其它服务端建立长连接时，这个时候，它根据LRU(Least Recently Used)算法进行处理，即将最使少使用的空闲连接KILL掉；
IE从4.0.1开始支持，IE6、7只支持两个长连接，IE8支持6个，IE 60秒为默认的超时时间，这个值可以在注册表中修改；
FF类似IE通过timeout管理长连接，不过，默的是115秒，这个是可能通过配置进行更改的；
Opera从4.0开始支持长连接，长连接数可以自定义；

**tcp短连接优缺点：**短连接对于服务器来说较为简单，存在的连接都是有用的连接，不需要额外的控制，但如果客户端连接频繁，会在tcp的建立和关闭上浪费时间。

### 为什么服务器会缓存这一项功能?如何实现的？

**原因**

- 缓解服务器压力；
- 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。

**实现方法**

- 让代理服务器进行缓存；
- 让客户端浏览器进行缓存。



## 3、Cookie

HTTP 协议是**无状态**的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务，HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie 是**服务器发送到用户浏览器并保存在本地的一小块数据**，**它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器**。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。

新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。

cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。

抽象地概括一下：一个 cookie 可以认为是一个「变量」，形如 name=value，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。

### Cookie有什么用途？用途

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

## 4、Session（会话）

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

### a.使用 Session 的过程

过程如下：

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

**注意**：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。

### b.Cookies和Session区别是什么？

Cookie和Session都是客户端与服务器之间保持状态的解决方案 1，存储的位置不同，cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全 2，存储的数据类型不同 两者都是key-value的结构，但针对value的类型是有差异的 **cookie：value只能是字符串类型**，**session：value是Object类型** 3，存储的数据大小限制不同 cookie：大小受浏览器的限制，很多是是4K的大小， session：理论上受当前内存的限制， 4，生命周期的控制 cookie的生命周期当浏览器关闭的时候，就消亡了 (1)cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束， (2)session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁

## 5、HTTP请求方法

客户端发送的 **请求报文** 第一行为请求行，包含了方法字段。

根据 HTTP 标准，HTTP 请求可以使用多种请求方法。

HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序 号 | 方法    | 描述                                                         |
| ----- | ------- | ------------------------------------------------------------ |
| 1     | GET     | 请求指定的页面信息，并返回实体主体。                         |
| 2     | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3     | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4     | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| 5     | DELETE  | 请求服务器删除指定的页面。                                   |
| 6     | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
| 7     | OPTIONS | 允许客户端查看服务器的性能。                                 |
| 8     | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
| 9     | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

### GET 和 POST 的区别

1. get是获取数据，post是发送数据到后台

2. get请求也可以传参数到后台，参数会在URL栏可见；参数之间以&相连，所以get不太安全，参数长度有限制；post请求传递的参数放在HTTP的包体内（request body）中，不会在URL中展示，比get安全；

3. get请求刷新浏览器或回退是没有影响。post请求回退时会重新提交数据请求；

4. get请求可以缓存，post请求没有缓存；

5. get请求会保存在浏览器历史记录中，post请求不会保存在浏览器历史记录中；

6. get请求产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);post请求产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。

7. 本质区别：GET是幂等的，而POST不是幂等的

   > 这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。

正因为它们有这样的区别，所以不应该且**不能用get请求做数据的增删改这些有副作用的操作**。因为get请求是幂等的，**在网络不好的隧道中会尝试重试**。如果用get请求增数据，会有**重复操作**的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。

# 三、HTTPS

HTTPS 并不是新协议，而是让 **HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信**。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

## 1、HTTP的缺点有哪些？

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

## 2、HTTPS采用的加密方式有哪些？是对称还是非对称？

HTTPS 采用混合的加密机制，使用**非对称密钥加密用于传输对称密钥来保证传输过程的安全性**，之后使用**对称密钥加密进行通信来保证通信过程的效率**。

## 3、非对称密钥加密你了解吗？优缺点？

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。

公开密钥所有人都可以获得，**通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密**，**接收方收到通信内容后使用私有密钥解密**。

非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此**通信发送方使用其私有密钥进行签名**，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢。

# 四、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？

1、查浏览器缓存，看看有没有已经缓存好的，如果没有

2 、检查本机host文件，

3、调用API，Linux下Scoket函数 gethostbyname

4、向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议

5、如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球400多个根DNS服务器，由13个不同的组织管理）

6、这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会，首先尝试http然后调用Socket建立TCP连接，

7、经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了，

8、如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事，

9、再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，

10、这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。

11、确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页