# 1、概述

配接器在STL组件中，扮演者轴承、转换器的角色。Adapter这个概念，事实上是一种设计模式。定义如下：**将一个class 的接口转换为另一个 class 的接口，使原本因接口不兼容而不能合作的 class，可以一起运作**。

STL所提供的配接器，可以分为三类：

**1、容器适配器，改变容器的接口**
**2、迭代器适配器，改变迭代器的接口**
**3、仿函数适配器，改变仿函数的接口**

# 2、容器适配器

C++中的容器适配器是干什么的呢？我们已有容器（比如vector、list、deque），他们支持的的操作很多，比如插入，删除，迭代器访问等等。而我们希望这个容器表现出来的是栈的样子：先进后出，入栈出栈等等，此时，我们没有必要重新动手写一个新的数据结构，而是把原来的容器重新封装一下，改变它的接口，就能把它当做栈使用了。

C++中定义了3种容器适配器，它们让容器提供的接口变成了我们常用的的3种数据结构：**栈stack，队列queue和优先队列priority_queue**。

默认情况下，**栈和队列都是基于deque实现的，而优先级队列则是基于vector实现的**。

当然，我们也可以指定自己的实现方式。但是由于数据结构的关系，我们也不能胡乱指定。栈的特点是后进先出，所以它关联的基本容器可以是任意一种顺序容器，因为这些容器类型结构都可以提供栈的操作有求，它们都提供了push_back、pop_back和back操作。 队列queue的特点是先进先出，适配器要求其关联的基础容器必须提供pop_front操作，因此其不能建立在vector容器上；对于优先级队列，由于它要求支持随机访问的功能，所以可以建立在vector或者deque上，不能建立在list上。


# 3、迭代器适配器

**STL提供了许多应用于迭代器身上的配接器，包括 insert iterators、reverse iterators、iostream iterators**。

## 3.1、Insert Iterators

**Insert Iterators就是可以将一般迭代器的赋值操作转变为插入操作**。这样的迭代器包括专司尾端插入操作的 back_insert_iterator，专司头端插入操作的 front_insert_iterator，以及可从任意位置执行插入操作的 insert_iterator。

由于这三个 iterator adapters 的使用接口不是很直观，STL 提供了三个相应函数：back_inserter()、front_inserter()、inserter()。

## 3.2、Reverse Iterators

所谓的 Reverse Iterators，可以将一般迭代器的行进方向逆转，使原本应该前进的 operator++ 变成了后退操作，使原本应该后退的 operator-- 变成了前进操作。这种错乱的行为不是为了掩人耳目，而是因为这种倒转性质运用在 “从尾端开始进行” 的算法上，有很大的方便性。

## 3.3、IOstream Iterators

可以将迭代器绑定到某个 iostream 对象上。绑定到 istream 对象身上的，称为 istream_iterator，拥有输入功能；绑定到 ostream 对象身上的，称为 ostream_iterator，拥有输出功能。这种迭代器运用于屏幕输出非常方便。以它为蓝图，稍加修改，便可适用于任何输出或输入装置上。

# 4、仿函数适配器

仿函数适配器是所有配接器中数量最庞大的一个族群，其配接灵活度也是前两者所不能及，可以配接、配接、在配接。这些配接器包括系结（bind）、否定（negate）、组合（compose）、以及对一般函数或成员函数的修饰。

仿函数配接器的价值在于，通过它们之间的绑定、组合、修饰能力，几乎可以无限制地创造出各种可能的表达式，搭配算法一起使用。

例如：希望找出某个序列中所有不小于12的元素个数，可写为：

```c++
not1( bind2nd( less<int>( ), 12 ) )

```

这个式子将 less() 的第二个参数绑定为12，在加上否定操作便形成了不小于12的语义。

例如：我们希望对序列中的每个元素都做某个特殊运算，这个运算的数学表达式为：f(g(elem))
其中 f 和 g 都是数学函数，那么可以这么写：

```c++
compose1( f( x )，g( y ) )

```

这一长串形成的表达式，可以拿来和任何接受表达式的算法搭配。不过需要注意的是，这个算式会改变参数的值。

由于仿函数就是 “将 function call 操作符重载” 的一种class，而任何算法接受一个仿函数时，总是在其演算过程中调用该仿函数的 operator() ，这使得不具备仿函数的之形，却有仿函数之实的 “一般函数” 和 “成员函数” 感到为难。为此，STL提供了为数众多的配接器，使一般函数和成员函数得以无缝隙地与其他配接器或算法结合起来。比如：mem_fun处理成员函数，ptr_fun处理一般函数。

**感谢大家，我是假装很努力的YoungYangD（小羊）**。

参考资料：
《STL源码剖析》